---
title: "ST558 - Vignette Project - Covid-19 Data"
author: "Jasmine Wang"
date: "10/07/2021"
output: 
  html_document:
    toc: yes
    code_folding: hide
    df_print: "paged"
---

```{r setup, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(fig.path = "../images/")
```


```{r echo=TRUE, eval=FALSE}
rmarkdown::render("C:/Users/peach/Documents/ST558/ST558_repos/vignette_project/_Rmd/ST558_vignette_proj.Rmd", 
                  output_format = "github_document", 
                  output_file = "C:/Users/peach/documents/ST558/ST558_repos/vignette_project/_README/README.md", 
                  output_options = list(html_preview = FALSE, toc = TRUE, df_print = "tibble")
)
```

## Required Packages

Below is a list of packages needed to create the vignette:  
  
* `httr`  
* `jsonlite`  
* `countrycode`  
* `tidyverse`  
* `ggplot2`  

```{r eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
library(httr)
library(jsonlite)
library(tidyverse)
library(countrycode)

######## General summary/countries/all####################################################
general_input <- function(gen_input, ...){
  
  input1 <- tolower(gen_input, ...) 
  option <- c("all", "summary", "countries")
  num <- charmatch(input1, option, ...)
  
  if(!is.na(num)) {
    
    status_string <- option[num]
    status_string
    
  } else {
    
    print("Sorry mate, your input is not valid! Please choose another one.")
  }
}

####### Country ###########################################################################
country <- function(country_name, ...){
  
  if(nchar(country_name) == 3) {
    
    nation_name <- countrycode(as.character(country_name), origin = "iso3c", destination = "country.name", ...)
    nation_name <- if_else(grepl(" ", nation_name, ignore.case = TRUE), tolower(sub(" ", "-", nation_name)), tolower(nation_name), ...)
    nation_name <- paste("country", nation_name, sep = "/", ...)
    nation_name
    
  } else if(nchar(country_name) == 2) {
    
    nation_name <- countrycode(as.character(country_name), origin = "iso2c", destination = "country.name", ...)
    nation_name <- if_else(grepl(" ", nation_name, ignore.case = TRUE), tolower(sub(" ", "-", nation_name)), tolower(nation_name), ...)
    nation_name <- paste("country", nation_name, sep = "/", ...)
    nation_name
    
  } else {
    
    nation_name <- if_else(grepl(" ", country_name, ignore.case = TRUE), tolower(sub(" ", "-", country_name)), tolower(country_name), ...)
    nation_name <- paste("country", nation_name, sep = "/", ...)
    nation_name
  }
}
#countrycode('Albania', origin = 'country.name', destination = 'iso3c')
#countrycode(nation, origin = "iso3c", destination = "country.name")

####### Status ### confirmed/recovered/deaths #####################################
status_input <- function(status, ...){
  
  input <- tolower(status, ...)
  option <- c("confirmed", "recovered", "deaths")
  num <- charmatch(input, option, ...)
  
  if(!is.na(num)) {
    
    status_string <- paste("status", option[num], sep="/", ...)
    status_string
    
  } else {
    
    print("Sorry mate, your input is not valid! Please choose another one.")
  }
}

####### Date Function ####################################################################
date_input_from <- function(date_from, ...){
  
  y <- c(date_from)
  y <- as_tibble(y)
  
  if(grepl("/", y$value, ignore.case = TRUE, ...)){
    
    temp <- y %>% separate(value, c("first", "second", "third"), sep="/", ...)
    
  } else if(grepl("-", y$value, ignore.case = TRUE, ...)) {
    
    temp <- y %>% separate(value, c("first", "second", "third"), sep="-", ...)
    
  } else {
    
    temp <- y %>% separate(value, c("first", "second", "third"), sep=" ", ...)
  }
  if(nchar(temp$first) == 4){
    
    if(nchar(temp$second) == 1){
      
      temp$second <- paste0("0", temp$second, ...)
      
      if(nchar(temp$third) == 1){
        
        temp$third <- paste0("0", temp$third, ...)
      }
    }
    temp <- unite(temp, date, first, second, third, sep="-", remove = TRUE, ...)
    temp$date
    
  } else {
    
    if(nchar(temp$second) == 1){
      
      temp$second <- paste0("0", temp$second, ...)
      
      if(nchar(temp$third) == 1){
        
        temp$third <- paste0("0", temp$third, ...)
      }
    }
    
    temp <- unite(temp, date, first, second, third, sep="-", remove = TRUE, ...)
    temp$date <- mdy(temp$date, ...)
    temp$date  
  }
}

date_input_to <- function(date_to, ...){
  
  y <- c(date_to)
  y <- as_tibble(y)
  
  if(grepl("/", y$value, ignore.case = TRUE, ...)){
    
    temp <- y %>% separate(value, c("first", "second", "third"), sep="/", ...)
    
  } else if(grepl("-", y$value, ignore.case = TRUE, ...)) {
    
    temp <- y %>% separate(value, c("first", "second", "third"), sep="-", ...)
    
  } else {
    
    temp <- y %>% separate(value, c("first", "second", "third"), sep=" ", ...)
  }
  if(nchar(temp$first) == 4){
    
    if(nchar(temp$second) == 1){
      
      temp$second <- paste0("0", temp$second, ...)
      
      if(nchar(temp$third) == 1){
        
        temp$third <- paste0("0", temp$third, ...)
      }
    }
    temp <- unite(temp, date, first, second, third, sep="-", remove = TRUE, ...)
    temp$date
    
  } else {
    
    if(nchar(temp$second) == 1){
      
      temp$second <- paste0("0", temp$second, ...)
      
      if(nchar(temp$third) == 1){
        
        temp$third <- paste0("0", temp$third, ...)
      }
    }
    
    temp <- unite(temp, date, first, second, third, sep="-", remove = TRUE, ...)
    temp$date <- mdy(temp$date, ...)
    temp$date  
  }
}

######### Time Function ##################################################################
time_input_from <- function(time_from, ...){
  
  times <- c(time_from)
  times <- as_tibble(times)
  
  if(grepl(":", times$value, ignore.case = TRUE, ...)) {
    
    times <- times %>% separate(value, c("first", "second", "third"), sep=":", ...)
    
  } else if(grepl("-", times$value, ignore.case = TRUE, ...)) {
    
    times <- times %>% separate(value, c("first", "second", "third"), sep="-", ...)
    
  } else if(grepl("/", times$value, ignore.case = TRUE, ...)) {
    
    times <- times %>% separate(value, c("first", "second", "third"), sep="/", ...)
    
  }
  
  if(nchar(times$first) == 1){
    
    times$first <- paste0("0", times$first, ...)
    
    if(nchar(times$second) == 1){
      
      times$second <- paste0("0", times$second, ...)
      
      if(nchar(times$third) == 1){
        
        times$third <- paste0("0", times$third, ...)
        
      }
    }
  }
  
  if(as.numeric(times$first) %in% c(0:23)){
    
    if(as.numeric(times$second) %in% c(0:59)){
      
      if(as.numeric(times$third) %in% c(0:59)){
        
        
        times <- unite(times, value, first, second, third, sep=":", remove = TRUE, ...)
        times$value
        
      } else {
        
        print("Sorry mate, your input is not valid! Please choose a time between 0 and 59 seconds.")
        
      }
    } else {
      
      print("Sorry mate, your input is not valid! Please choose a time between 0 and 59 minutes.")
      
    }
  } else {
    
    print("Sorry mate, your input is not valid! Please choose a military time between 0 and 23 hours.")
    
  }
}

time_input_to <- function(time_to, ...){
  
  times <- c(time_to)
  times <- as_tibble(times)
  
  if(grepl(":", times$value, ignore.case = TRUE, ...)) {
    
    times <- times %>% separate(value, c("first", "second", "third"), sep=":", ...)
    
  } else if(grepl("-", times$value, ignore.case = TRUE, ...)) {
    
    times <- times %>% separate(value, c("first", "second", "third"), sep="-", ...)
    
  } else if(grepl("/", times$value, ignore.case = TRUE, ...)) {
    
    times <- times %>% separate(value, c("first", "second", "third"), sep="/", ...)
    
  }
  
  if(nchar(times$first) == 1){
    
    times$first <- paste0("0", times$first, ...)
    
    if(nchar(times$second) == 1){
      
      times$second <- paste0("0", times$second, ...)
      
      if(nchar(times$third) == 1){
        
        times$third <- paste0("0", times$third, ...)
        
      }
    }
  }
  
  if(as.numeric(times$first) %in% c(0:23)){
    
    if(as.numeric(times$second) %in% c(0:59)){
      
      if(as.numeric(times$third) %in% c(0:59)){
        
        
        times <- unite(times, value, first, second, third, sep=":", remove = TRUE, ...)
        times$value
        
      } else {
        
        print("Sorry mate, your input is not valid! Please choose a time between 0 and 59 seconds.")
        
      }
    } else {
      
      print("Sorry mate, your input is not valid! Please choose a time between 0 and 59 minutes.")
      
    }
  } else {
    
    print("Sorry mate, your input is not valid! Please choose a military time between 0 and 23 hours.")
    
  }
}

############# A P I ##########################################################################
ref_general <- function(gen_input = "countries", ...){
  
  info1 <- general_input(gen_input, ...)
  
  api_url <- if_else(info1 %in% c("all", "summary", "countries"), 
                     paste("https://api.covid19api.com", info1, sep = "/"), info1, ...)
  api_url
  
}

dayone_all_status <- function(country_name = "BB", ...){
  
  info2 <- country(country_name, ...)
  
  api_url <- paste("https://api.covid19api.com/dayone", info2, sep = "/", ...)
  api_url
  
}

dayone_status <- function(country_name = "BB", status = "confirmed", ...){
  
  info2 <- country(country_name, ...)
  info3 <- status_input(status, ...)
  
  api_url <- paste("https://api.covid19api.com/dayone", info2, info3, sep = "/", ...)
  api_url
  
}

dayone_status_live <- function(country_name = "BB", status = "confirmed", ...){
  
  info2 <- country(country_name, ...)
  info3 <- status_input(status, ...)
  
  api_url <- paste("https://api.covid19api.com/dayone", info2, info3, "live", sep = "/", ...)
  api_url
  
}

datetime_specific_all_status <- function(country_name="BB", date_from="2020-05-01", date_to="2020-05-03", 
                                             time_from="00:00:00", time_to="00:00:00", ...){
  
  info2 <- country(country_name, ...)
  
  date1 <- date_input_from(date_from, ...)
  date2 <- date_input_to(date_to, ...)
  time1 <- time_input_from(time_from, ...)
  time2 <- time_input_to(time_to, ...)
  
  latter <- paste0("?from=", date1, "T", time1, "Z&to=", date2, "T", time2, "Z", ...)
  api_url <- paste0("https://api.covid19api.com/", info2, latter, ...)
  api_url
  
}

datetime_specific_status <- function(country_name="BB", status="confirmed", date_from="2020-05-01", date_to="2020-05-03", 
                                         time_from="00:00:00", time_to="00:00:00", ...){
  
  info2 <- country(country_name, ...)
  info3 <- status_input(status, ...)
  
  date1 <- date_input_from(date_from, ...)
  date2 <- date_input_to(date_to, ...)
  time1 <- time_input_from(time_from, ...)
  time2 <- time_input_to(time_to, ...)
  
  latter <- paste0("?from=", date1, "T", time1, "Z&to=", date2, "T", time2, "Z", ...)
  api_url <- paste0("https://api.covid19api.com/", info2, "/", info3, latter, ...)
  api_url
  
}

live_all_status <- function(country_name = "BB", ...){
  
    info2 <- country(country_name, ...)
  
  api_url <- paste("https://api.covid19api.com/live", info2, sep = "/", ...)
  api_url
  
}

live_status <- function(country_name = "BB", status = "confirmed", ...){
  
  info2 <- country(country_name, ...)
  info3 <- status_input(status, ...)
  
  api_url <- paste("https://api.covid19api.com/live", info2, info3, sep = "/", ...)
  api_url
  
}

live_status_after_date <- function(country_name = "BB", status = "confirmed", 
                                   date_from="2020-05-01", time_from="00:00:00", ...){
  
  info2 <- country(country_name, ...)
  info3 <- status_input(status, ...)
  
  date1 <- date_input_from(date_from, ...)
  time1 <- time_input_from(time_from, ...)
  datetime <- paste0(date_from, "T", time_from, "Z", ...)
  
  api_url <- paste("https://api.covid19api.com/live", info2, info3, "date", datetime,  sep = "/", ...)
  api_url
  
}
```

## Writing Functions

I wrote some mini-functions so that the input arguments are user-friendly to query the Covid-19 data from [Covid-19 API](https://covid19api.com/). I created a wrapper function, `choose_api`, which contains nine customized functions to obtain the correct API URL to query the data needed for the users. Users only need to supply with arguments like the country they want to query from, status of the query (total confirmed cases, recovered cases, or number of deaths), and starting at certain date and time they want to query the data. Users can use `choose_api` function to check if their query API URL is correct to query the data they need. Then, they can use the exact same arguments they used in the `choose_api` function in the `get_data` function to obtain the parsed data in a usable form. Thus, if the API URL obtained from `choose_api` function is not correct, those same arguments are surely not going to work in the `get_data` function. Therefore, `choose_api` function is a way to see if the user-supplied arguments are correct, and the obtained API URL is what the users want to query. 

Let's look at the options of the data the customized functions can query:  

1. **general** option, `ref_general` function:  
    + *summary* returns a summary of new and total cases per country, updated daily.  
    + *countries* returns all the available countries and provinces, and the country slug for per country requests.  
    + *all* returns all daily data. WARNING: This call results in > 10MB of data being returned and should be used infrequently.  
    + `choose_api(type = 1, gen_input = "summary")`
    + https://api.covid19api.com/summary  
    
2. **option1** API, `dayone_all_status`:  
    + Returns all cases types including confirmed cases, recovered cases and deaths for a country from the first recorded case. 
    + `choose_api(type = 2, country_name = "barbados")`  
    + https://api.covid19api.com/dayone/country/barbados  
    
3. **option2** API, `dayone_status`:  
    + Returns cases by case type for a country from the first recorded case. Case types must be one of confirmed, recovered or deaths.  
    + `choose_api(type = "option2", country_name = "barbados", status = "confirmed")`
    + https://api.covid19api.com/dayone/country/barbados/status/confirmed  
    
4. **option3** API, `dayone_status_live`:  
    + Returns cases by case type for a country from the first recorded case with the latest record being the live count. Case types must be one of confirmed, recovered or deaths.  
    + `choose_api(type = "option3", country_name = "barbados", status = "confirmed")`  
    + https://api.covid19api.com/dayone/country/barbados/status/confirmed/live  
    
5. **option4** API, `datetime_specific_all_status`:  
    + Returns all cases types including confirmed cases, recovered cases and deaths for a country. Date and time can vary and be chosen by users.  
    + `choose_api(type = 5, country_name = "barbados", date_from = "2020-05-01", date_to = "2020-05-03", time_from = "00:00:00", time_to = "00:00:00")` 
    + https://api.covid19api.com/country/barbados?from=2020-05-01T00:00:00Z&to=2020-05-03T00:00:00Z  
    
6. **option5** API, `datetime_specific_status`:  
    + Returns cases by case type for a country. Date and time can vary and be chosen by users. Case types must be one of confirmed, recovered or deaths.  
    + `choose_api(type = "option5", country_name = "barbados", status = "confirmed", date_from = "2020-05-01", date_to = "2020-05-03", time_from = "00:00:00", time_to = "00:00:00")`
    + https://api.covid19api.com/country/barbados/status/confirmed?from=2020-05-01T00:00:00Z&to=2020-05-03T00:00:00Z  
    
7. **option6** API, `live_all_status`:  
    + Returns all live cases types including confirmed cases, recovered cases and deaths for a country. These records are pulled every 10 minutes and are ungrouped.  
    + `choose_api(type = 7, country_name = "barbados")`  
    + https://api.covid19api.com/live/country/barbados  
    
8. **option7** API, `live_status`:  
    + Returns live cases by case type for a country. These records are pulled every 10 minutes and are ungrouped. Case types must be one of confirmed, recovered or deaths.  
    + `choose_api(type = 8, country_name = "barbados", status = "confirmed")`
    + https://api.covid19api.com/live/country/barbados/status/confirmed  
    
9. **option8** API, `live_status_after_date`:  
    + Returns live cases by case type for a country after a given date/time. These records are pulled every 10 minutes and are ungrouped. Case types must be one of confirmed, recovered or deaths.  
    + `choose_api(type = "option8", country_name = "barbados", status = "confirmed", date_from = "2020-05-01", time_from = "00:00:00")`  
    + https://api.covid19api.com/live/country/barbados/status/confirmed/date/2020-05-01T00:00:00Z  
    
Simply use `choose_api(type, ...)` to get the desired API URL. Use argument, `type = 1` or `type = "general"`, to select the customized API function call for a summary or a list of available countries or all data. Use `type = 2` or `type = "option1"` to obtain the API URL for all cases types for a country since the first recorded case. 

If more argument inputs are needed, subsequent order of the arguments is:  
  
* "type" -> "country" -> "status" -> "date from" -> "date to" -> "time from" -> "time to"

If the desired API URL the users get from the `choose_api` function is correct, the same exact arguments used in `choose_api` will be used again in `get_data` function to query the data from Covid-19 API site. 

```{r eval=TRUE, cache=TRUE}
choose_api <- function(type, ...) {
  
  switch(type,
         
         general = ref_general(...),
         option1 = dayone_all_status(...),
         option2 = dayone_status(...),
         option3 = dayone_status_live(...),
         option4 = datetime_specific_all_status(...),
         option5 = datetime_specific_status(...),
         option6 = live_all_status(...),
         option7 = live_status(...),
         option8 = live_status_after_date(...)
  )
}

get_data <- function(type, ...){
  
  api_url <- choose_api(type, ...)
  json_data <- GET(api_url)
  extract_data <- rawToChar(json_data$content)
  usable_form <- fromJSON(extract_data)
  usable_form
  
}
```

The table below show a list of customized API functions with their corresponding arguments and defaults set. 

Function(s)                    | Argument(s)                                                              | Default(s)
------------------------------ | ------------------------------------------------------------------------ | -------------------------
`ref_general`                  | `gen_input`                                                              | None for `gen_input`
`dayone_all_status`            | `country_name`                                                           | `country_name = "BB"`
`dayone_status`                | `country_name`, `status`                                                 | `status = "confirmed"`
`dayone_status_live`           | `country_name`, `status`                                                 | `date_from = "2020-05-01"`
`datetime_specific_all_status` | `country_name`, `date_from`, `date_to`, `time_from`, `time_to`           | `date_to = "2020-05-03"`
`datetime_specific_status`     | `country_name`, `status`, `date_from`, `date_to`, `time_from`, `time_to` | `time_from = "00:00:00"`
`live_all_status`              | `country_name`                                                           | `time_to = "00:00:00"`
`live_status`                  | `country_name`, `status`                                                 |
`live_status_after_date`       | `country_name`, `status`, `date_from`, `time_from`                       |

Let's look at the options each argument can take:  
  
1. `gen_input`:  
    + Can take or partially match these options, `"summary"`, `"countries"`, `"all"` (or "Su", "SuM", "sUmMa"). Non-case sensitive.  
    + I did not set a default value for `gen_input` function because using the API URL generated by this function will query a large data set and will be time-consuming. Therefore, unless the users really want to query from these options, I do not want them to accidentally set it off. In a word, if the users really want to query from these options, they can input those arguments themselves. Otherwise, I would recommend to go to the [Covid-19 API site](https://documenter.getpostman.com/view/10808728/SzS8rjbc#00030720-fae3-4c72-8aea-ad01ba17adf8) to see the example lists from these options.  
    
2. `country_name`:  
    + Must be the slug country name from the available list or 2-letter (ISO2) or 3-letter (ISO3) abbreviations.  
    + For example, "uNitED-sTATes", "UnItEd StAtES", "uSa" and "uS" are all valid inputs. Non-case sensitive.  
    + Default country is Barbados. 
    
3. `status`:  
    + Can take or partially match these options, `"confirmed"`, `"recovered"`, `"deaths"` (or "Co", "cOn", "cOnf"). Non-case sensitive.  
    + Default status is "confirmed".
    
4. `date_from` and `date_to`:  
    + Can take "2020 12 31", "12/31/2021", "2020-12-31", "3 20 2021", "2020 10 6".  
    + Note: If users request data from dates that are before Covid-19 time for a country, i.e. 2018, this may result in an error or the data contains all zero lists.  
    + Default for `date_from` is "2020-05-01" and for `date_to` is "2020-05-03".
    
5. `time_from` and `time_to`:  
    + *Hour* can take any numeric values from 0 to 23 (must be in military time).  
    + *Minute* can take any numeric values from 0 to 59.  
    + *second* can take any numeric values from 0 to 59.  
    + Can take "1:4:5", "1/4/5", "1-4-5" (all equivalent to "01:04:05").  
    + Default for both `time_from` and `time_to` is "00:00:00:

Note: If users do not supply any argument inputs but simply choose an option function to guery the data, it will return cases results for Barbados from May 1st, 2020, at time 00:00:00 to May 3rd, 2020, at time 00:00:00. 

Note2: Free API query does not require a key for this Covid-19 API site. However,!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

## Getting an API

Below is the API URL I used in the `get_data` function I created to query the data for all cases type for the United States from January 3rd, 2021 to January 5th, 2021 (3 days). We can see it returns for 10,000 rows and 13 columns including every city from every state in the United States for 3 days worth of all cases type of data. I realized by looking at this example data that all cases types are accumulated up untill the date/time queried. If I want to calculate all cases types for each month for each state in the United States, I can query one day of data at the end of each month, group by each state and sum up all different cases type, subtrack them from the previous end of month one day data. Then, we will have the number of all cases types per state per month, not cumulatively. Let's see if this works!

```{r eval=FALSE}
choose_api(5, "usa", date_from="2021 1 3", date_to="2021 1 5", time_to="23:59:59")
test_data <- get_data(5, "usa", date_from="2021 1 3", date_to="2021 1 5", time_to="23:59:59")
test_data <- test_data %>% group_by(City)
test_data
```

### Getting Data

Since the free Covid-19 data query does not require a key and has limited access/queries. For instance, each time we make a request to query, we can only query data for a range up to a week. Thus, I made a single-day query for the last day of each month from December 2020 to September 2021 since the data is accumulated. I only selected five columns (*Province*, *Confirmed*, *Deaths*, *Active*, *Date*) from each query and saved them to an object named by a month of that query. I row-combined those objects/queries into two different data sets since they all have the same column names. This way I did so that I can column-combine them later and subtract the same case type for each state for each month. The example I had in mind is shown in the table below.
  
* Confirmed = Confirmed_cases - Confirmed_cases2  

Province       | Confirmed_cases | Confirmed_cases2 | Month
-------------- | --------------- | ---------------- | ---------
North Carolina | 4569 (Jan 2021) | 4123 (Dec 2020)  | January
North Carolina | 5638 (Feb 2021) | 4569 (Jan 2021)  | February
North Carolina | ...             | 5638 (Feb 2021)  | March

```{r eval=TRUE, cache=FALSE}
dec <- get_data(5, "usa", date_from="2020 12 31", date_to="2020 12 31", time_to="23:59:59")
jan <- get_data(5, "usa", date_from="2021 1 31", date_to="2021 1 31", time_to="23:59:59")
feb <- get_data(5, "usa", date_from="2021 2 28", date_to="2021 2 28", time_to="23:59:59")
mar <- get_data(5, "usa", date_from="2021 3 31", date_to="2021 3 31", time_to="23:59:59")
apr <- get_data(5, "usa", date_from="2021 4 30", date_to="2021 4 30", time_to="23:59:59")
may <- get_data(5, "usa", date_from="2021 5 31", date_to="2021 5 31", time_to="23:59:59")
jun <- get_data(5, "usa", date_from="2021 6 30", date_to="2021 6 30", time_to="23:59:59")
jul <- get_data(5, "usa", date_from="2021 7 31", date_to="2021 7 31", time_to="23:59:59")
aug <- get_data(5, "usa", date_from="2021 8 31", date_to="2021 8 31", time_to="23:59:59")
sep <- get_data(5, "usa", date_from="2021 9 30", date_to="2021 9 30", time_to="23:59:59")

dec_2 <- dec %>% select(Province, Confirmed, Deaths, Active, Date) 
jan_2 <- jan %>% select(Province, Confirmed, Deaths, Active, Date)
feb_2 <- feb %>% select(Province, Confirmed, Deaths, Active, Date)
mar_2 <- mar %>% select(Province, Confirmed, Deaths, Active, Date)
apr_2 <- apr %>% select(Province, Confirmed, Deaths, Active, Date)
may_2 <- may %>% select(Province, Confirmed, Deaths, Active, Date)
jun_2 <- jun %>% select(Province, Confirmed, Deaths, Active, Date)
jul_2 <- jul %>% select(Province, Confirmed, Deaths, Active, Date)
aug_2 <- aug %>% select(Province, Confirmed, Deaths, Active, Date)
sep_2 <- sep %>% select(Province, Confirmed, Deaths, Active, Date)

late_date <- rbind(jan_2, feb_2, mar_2, apr_2, may_2, jun_2, jul_2, aug_2, sep_2)
early_date <- rbind(dec_2, jan_2, feb_2, mar_2, apr_2, may_2, jun_2, jul_2, aug_2)
```

### Data Manipulation

At this point, I have data from every city in each state. So, I grouped by *Province* and *Date* and sum up all different case types for each state for the same date. I applied this to both data sets. Then, I changed the names of the columns in one of the datasets in order to perform a column-combination of the two tables afterwards and saved it as an object, *mydata1*. Now, *mydata1* is in a format I had in mind earlier as shown in the table above. 

```{r eval=TRUE}
after_date <- late_date %>% group_by(Province, Date) %>% summarise(across(c(Confirmed, Deaths, Active), sum))
before_date <- early_date %>% group_by(Province, Date) %>% summarise(across(c(Confirmed, Deaths, Active), sum))

names(before_date) <- c("State", "Date2", "Confirmed2", "Deaths2", "Active2")
mydata1 <- cbind(after_date, before_date)
mydata1
```

### Creating Variables

Now we are ready to subtract each case type from itself from the previous month and obtain the total number of confirmed cases, active cases and deaths for each month for each state. Then, we can compare those numbers between different states.

Four variables are created here, and we do not keep the old variables we used to compute the new ones. These variables are now representative numbers for the corresponding month and state. They are no longer the cumulative figures.
  
* *Total*  
* *Month*  
* *Deaths*  
* *Active*  

You can also save this data to your local drive in case of an unexpected event occurred such as website maintenance. 

```{r eval=TRUE, cache=FALSE}
mydata2 <- mydata1 %>% mutate(Total = Confirmed - Confirmed2, Death = Deaths - Deaths2, Active_cases = Active - Active2, 
                              Month = rep(c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"))) %>% 
  select(State, Month, Total, Death, Active_cases)
names(mydata2) <- c("Province","State", "Month", "Total", "Deaths", "Active")
mydata2

# write_csv(x = mydata2, path = "../_Data/covid_data.csv")
```

### Creating an Infix Function and Categorical Variables

Upon inspecting the data, I discovered eight states I did not want to be included in the data analysis. So, I created an infix function, `%!in%`, that is negation of the infix function, `%in%`. I used it to filter the rows whenever *Province* contains those states. These states I excluded from the data are: "American Samoa", "Diamond Princess", "Grand Princess", "Guam", "Northern Mariana Islands", "Puerto Rico" and "Virgin Islands". They may be potential outliers since their number of cases may be really low for each case type. 

I used `mutate` function to create three categorical variables using the numerical variables we just obtained.  
  
* *f500_deaths* (2 levels):  
    + Less than 500 deaths  
    + More than 500 deaths  
    
* *Total_cases* (3 levels):  
    + Less than 9000  
    + Between 9000 and 30,000  
    + More than 30,000  
    
* *vaccine* (3 levels):  
    + Vaccine-ing  
    + Some vaccined  
    + Back to school  
    
```{r eval=TRUE, cache=TRUE}
`%!in%` <- Negate(`%in%`)

mydata3 <- mydata2 %>% filter(Province %!in% c("American Samoa", "Diamond Princess", "Grand Princess", "Guam", "Northern Mariana Islands", "Puerto Rico", "Virgin Islands")) %>% 
  mutate(f500_deaths = if_else(Deaths < 500, "Less than 500 deaths", "More than 500 deaths"), 
         Total_cases = if_else(Total < 9000, "1. Less than 9000", 
                             if_else(Total < 30000, "2. Between 9000 and 30,000", "3. More than 30,000")), 
         vaccine = if_else(Month %in% c("Jan", "Feb", "Mar", "Apr"), "Vaccine-ing", 
                           if_else(Month %in% c("May", "Jun", "Jul"), "Some vaccined", "Back to school")))
```

## Contingency Tables





```{r eval=TRUE}
# 1st contingency table
table(mydata3$Total_cases, mydata3$vaccine)

# 2nd contingency table
mydata3 %>% filter(Province %in% c("California", "New York", "Florida", "Texas", "Michigan", "North Carolina")) %>% 
  select(Province, Month, Deaths) %>%
  pivot_wider(names_from = "Month", values_from = "Deaths") %>% arrange(desc(Jan))
# 3rd contingency table
mydata3 %>% filter(Province %in% c("California", "New York", "Florida", "Texas", "Michigan", "North Carolina")) %>% 
  select(Province, Month, Total) %>%
  pivot_wider(names_from = "Month", values_from = "Total") %>% arrange(desc(Jan))
```

## Numerical Summaries




```{r eval=TRUE}
# summaries
summary3 <- mydata3 %>% group_by(Province, vaccine) %>% 
  summarise(avg_total = round(mean(Total)), sd_total = round(sd(Total)), median_total = round(median(Total)), IQR_total = round(IQR(Total)))

summary4 <- mydata3 %>% group_by(Province, vaccine) %>% 
  summarise(avg_death = mean(Deaths), sd_death = sd(Deaths), median_death = median(Deaths), IQR_death = IQR(Deaths))

```

## Explanatory Data Analysis
### Barplots
### Boxplots
### Scatterplot
### Histogram
### Line Plots



```{r eval=FALSE}
library(tidyverse)
library(ggplot2)

barplot1 <- summary3 %>% filter(Province %in% c("California", "New York", "Florida", "Texas", "Michigan", "North Carolina"))
g <- ggplot(data = barplot1, aes(x = Province, y = avg_total, fill = vaccine))
g + geom_bar(stat = "identity", position = "dodge") + 
  labs(x = "State", y = "Average Total Cases", title = "Figure 1. Average total cases at each timeline for each state") + 
  scale_fill_discrete(name = "Vaccine timeline") + 
  theme(axis.text.x = element_text(angle = 45, size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 13), 
        axis.title.y = element_text(size = 13), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

barplot2 <- summary4 %>% filter(Province %in% c("California", "New York", "Florida", "Texas", "Michigan", "North Carolina"))
d <- ggplot(data = barplot2, aes(x = Province, y = avg_death, fill = vaccine))
d + geom_bar(stat = "identity", position = "dodge") + 
  labs(x = "State", y = "Average Total Cases", title = "Figure 2. Average total deaths at each timeline for each state") + 
  scale_fill_discrete(name = "Vaccine timeline") + 
  theme(axis.text.x = element_text(angle = 45, size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 13), 
        axis.title.y = element_text(size = 13), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

# mydata3

boxplot1 <- ggplot(data = mydata3, aes(x = vaccine, y = Total))
boxplot1 + geom_boxplot(fill = "white", outlier.shape = NA) + 
  coord_cartesian(ylim=c(0, 300000)) + 
  geom_jitter(aes(color = vaccine), size = 3) + 
  labs(title = "Figure 3. Boxplot for total number of cases") + 
  theme(axis.text.x = element_text(size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

boxplot2 <- ggplot(data = mydata3, aes(x = vaccine, y = Death))
boxplot2 + geom_boxplot(fill = "white", outlier.shape = NA) + 
  coord_cartesian(ylim=c(0, 10000)) + 
  geom_jitter(aes(color = vaccine), size = 3) + 
  labs(title = "Figure 4. Boxplot for total number of deaths") + 
  theme(axis.text.x = element_text(size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

scatter <- ggplot(data = mydata3, aes(x = Cases, y = Death, color = vaccine))
scatter + geom_point(aes(shape = Total_cases), size = 3) + 
  coord_cartesian(xlim=c(0, 1000000), ylim=c(0, 20000)) +
  geom_smooth(method = lm, lwd = 2) + 
  labs(title = "Figure 5. Scappterplot: Number of cases vs Deaths") + 
  theme(axis.text.x = element_text(size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

his <- ggplot(data = mydata3, aes(x = Total))
his + geom_histogram() + 
  coord_cartesian(xlim=c(0, 1000000)) + 
  labs(title = "Figure 6. Histogram of Total Cases via Timelines") + 
  theme(axis.text.x = element_text(size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

# mydata3$Month <- ordered(mydata3$Month, levels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"))
mydata3$Month <- factor(mydata3$Month, levels = unique(mydata3$Month))

neighbor <- mydata3 %>% filter(State %in% c("North Carolina", "South Carolina", "Tennessee","Georgia", "Kentucky", "Virginia", "West Virginia"))
lineplot1 <- ggplot(data = neighbor, aes(x = Month, y = Total, color = State))
lineplot1 + geom_line(aes(group = State)) + geom_point() + 
  labs(title = "Figure 7. Line plot: Total cases of NC and its neighbors") + 
  theme(axis.text.x = element_text(size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

lineplot1 <- ggplot(data = neighbor, aes(x = Month, y = Death, color = State))
lineplot1 + geom_line(aes(group = State)) + geom_point() + 
  labs(title = "Figure 8. Line plot: Total deaths of NC and its neighbors") + 
  theme(axis.text.x = element_text(size = 10), 
        axis.text.y = element_text(size = 10), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.key.size = unit(1, 'cm'), 
        legend.text = element_text(size = 13), 
        title = element_text(size = 15))

```



## Welcome to GitHub Pages

You can use the [editor on GitHub](https://github.com/peachgal/vignette_project/edit/main/README.md) to maintain and preview the content for your website in Markdown files.

Whenever you commit to this repository, GitHub Pages will run [Jekyll](https://jekyllrb.com/) to rebuild the pages in your site, from the content in your Markdown files.

### Markdown

Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for

```markdown
Syntax highlighted code block

# Header 1
## Header 2
### Header 3

- Bulleted
- List

1. Numbered
2. List

**Bold** and _Italic_ and `Code` text

[Link](url) and ![Image](src)
```

For more details see [GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/).

### Jekyll Themes

Your Pages site will use the layout and styles from the Jekyll theme you have selected in your [repository settings](https://github.com/peachgal/vignette_project/settings/pages). The name of this theme is saved in the Jekyll `_config.yml` configuration file.

### Support or Contact

Having trouble with Pages? Check out our [documentation](https://docs.github.com/categories/github-pages-basics/) or [contact support](https://support.github.com/contact) and we’ll help you sort it out.

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

